#include "anti_backlash.h"
#include <math.h>

/**
 * @brief Sign function: returns +1, -1, or 0 based on input value.
 */
int8_t sign(float32_t x) {
    if (x > 0.0f) {
        return 1;
    } else if (x < 0.0f) {
        return -1;
    } else {
        return 0;
    }
}

/**
 * @brief Initialize the backlash controller.
 * @param ctrl Pointer to controller structure.
 * @param backlash_width Estimated or measured backlash gap.
 */
void Backlash_Init(BacklashController *ctrl, float32_t backlash_width) {
    ctrl->backlash_width = backlash_width;
    ctrl->backlash_offset = 0.0f;
    ctrl->direction_prev = 0;
    ctrl->state = TRANSITION;
}

/**
 * @brief Updates backlash-compensated reference position.
 * @param ctrl Pointer to controller structure.
 * @param pos_ref Desired reference position.
 * @param pos_act Actual measured position.
 * @param vel Measured or estimated velocity.
 * @return Compensated position to use in control.
 */
float32_t Backlash_Update(BacklashController *ctrl, float32_t pos_ref, float32_t pos_act, float32_t vel) {
    int8_t direction_now = sign(vel);

    // Detect direction change
    if (direction_now != ctrl->direction_prev && direction_now != 0) {
        ctrl->direction_prev = direction_now;
        ctrl->state = TRANSITION;

        if (direction_now > 0) {
            ctrl->backlash_offset = ctrl->backlash_width;
        } else {
            ctrl->backlash_offset = -ctrl->backlash_width;
        }
    }

    // Apply backlash offset to reference
    float32_t pos_ref_compensated = pos_ref + ctrl->backlash_offset;

    // Check if backlash has been taken up
    if (ctrl->state == TRANSITION) {
        if (fabsf(pos_ref - pos_act) >= ctrl->backlash_width) {
            if (direction_now > 0) {
                ctrl->state = ENGAGED_POS;
            } else {
                ctrl->state = ENGAGED_NEG;
            }
            ctrl->backlash_offset = 0.0f;
        }
    }

    return pos_ref_compensated;
}
